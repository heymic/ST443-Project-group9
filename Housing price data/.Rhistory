df$Functional <- as.numeric(functional.list[df$Functional])
group.prices('GarageFinish')
garage.fin.list <- c('None' = 0,'Unf' = 1, 'RFn' = 1, 'Fin' = 2)
df$GarageFinish <- as.numeric(garage.fin.list[df$GarageFinish])
group.prices('Fence')
fence.list <- c('None' = 0, 'MnWw' = 1, 'GdWo' = 1, 'MnPrv' = 2, 'GdPrv' = 4)
df$Fence <- as.numeric(fence.list[df$Fence])
group.prices(df$MSSubClass)
require(Matrix) # matrix transformations
require(glmnet) # ridge, lasso & elastinet
require(xgboost) # gbm
require(randomForest)
require(Metrics) # rmse
require(dplyr) # load this in last so plyr doens't overlap it
require(caret) # one hot encoding
require(scales) # plotting $$
require(e1071) # skewness
require(corrplot) # correlation plot
Mode <- function(x) {
ux <- unique(x)
ux[which.max(tabulate(match(x, ux)))]
}
setwd("C:/Users/Michal/Documents/01- Master Degree/GitHub/ST443-Project-group9/Housing price data")
getwd()
train = read.csv("train.csv", row.names = "Id", stringsAsFactors=FALSE)
testing_kaggle = read.csv("test.csv", row.names = "Id", stringsAsFactors=FALSE)
#combining train and test data for quicker data prep
testing_kaggle$SalePrice <- NA
train$isTrain <- 1
testing_kaggle$isTrain <- 0
df <- rbind(train,testing_kaggle)
hist(df$SalePrice)
colSums(sapply(df, is.na))
df[,c('PoolQC','PoolArea')] %>%
group_by(PoolQC) %>%
summarise(mean = mean(PoolArea), counts = n())
df[(df$PoolArea > 0) & is.na(df$PoolQC),c('PoolQC','PoolArea')]
df[2421,'PoolQC'] = 'Ex'
df[2504,'PoolQC'] = 'Ex'
df[2600,'PoolQC'] = 'Fa'
df$PoolQC[is.na(df$PoolQC)] = 'None'
length(which(df$GarageYrBlt == df$YearBuilt))
df[which(is.na(df$GarageYrBlt)), 'GarageYrBlt'] <- df[which(is.na(df$GarageYrBlt)), 'YearBuilt']
garage.cols <- c('GarageArea', 'GarageCars', 'GarageQual', 'GarageFinish', 'GarageCond', 'GarageType')
#df[is.na(df$GarageCond),garage.cols]
for(i in garage.cols){
if (sapply(df[i], is.numeric) == TRUE){
df[,i][which(is.na(df[,i]))] <- 0
}
else{
df[,i][which(is.na(df[,i]))] <- "None"
}
}
df$KitchenQual[which(is.na(df$KitchenQual))] <- Mode(df$KitchenQual)
df[is.na(df$MSZoning),c('MSZoning','MSSubClass')]
table(df$MSZoning, df$MSSubClass)
df$MSZoning[c(2217, 2905)] = 'RL'
df$MSZoning[c(1916, 2251)] = 'RM'
df$LotFrontage[which(is.na(df$LotFrontage))] <- median(df$LotFrontage,na.rm = T)
df$Alley[which(is.na(df$Alley))] <- "None"
#df[(df$MasVnrArea > 0) & (is.na(df$MasVnrType)),c('MasVnrArea','MasVnrType')]
df[2611, 'MasVnrType'] = 'BrkFace'
df$MasVnrType[is.na(df$MasVnrType)] = 'None'
df$MasVnrArea[is.na(df$MasVnrArea)] = 0
for(i in colnames(df[,sapply(df, is.character)])){
if (sum(is.na(df[,i])) < 5){
df[,i][which(is.na(df[,i]))] <- Mode(df[,i])
}
}
for(i in colnames(df[,sapply(df, is.integer)])){
if (sum(is.na(df[,i])) < 5){
df[,i][which(is.na(df[,i]))] <- median(df[,i], na.rm = T)
}
}
for(i in colnames(df[,sapply(df, is.character)])){
df[,i][which(is.na(df[,i]))] <- "None"
}
colSums(sapply(df, is.na))
sum(is.na(df)) == 1459
str(df)
train <- df[df$isTrain==1,]
group.prices <- function(col) {
group.table <- train[,c(col, 'SalePrice', 'OverallQual')] %>%
group_by_(col) %>%
summarise(mean.Quality = round(mean(OverallQual),2),
mean.Price = mean(SalePrice), n = n()) %>%
arrange(mean.Quality)
print(qplot(x=reorder(group.table[[col]], -group.table[['mean.Price']]), y=group.table[['mean.Price']]) +
geom_bar(stat='identity', fill='cornflowerblue') +
theme_minimal() +
scale_y_continuous(labels = dollar) +
labs(x=col, y='Mean SalePrice') +
theme(axis.text.x = element_text(angle = 45)))
return(data.frame(group.table))
}
# function that maps a categoric value to its corresponding numeric value and returns that column to the data frame
map.fcn <- function(cols, map.list, dataframe1){
for (col in cols){
dataframe1[col] <- as.numeric(map.list[df[,col]])
}
return(dataframe1)
}
bsmt_list <- c('None' = 0, 'No' = 1, 'Mn' = 2, 'Av' = 3, 'Gd' = 4)
df = map.fcn(c('BsmtExposure'), bsmt_list, df)
bsmt_fin_list <- c('None' = 0, 'Unf' = 1, 'LwQ' = 2,'Rec'= 3, 'BLQ' = 4, 'ALQ' = 5, 'GLQ' = 6)
df <- map.fcn(c('BsmtFinType1','BsmtFinType2'), bsmt_fin_list, df)
qual.cols <- c('ExterQual', 'ExterCond', 'GarageQual', 'GarageCond', 'FireplaceQu', 'KitchenQual', 'HeatingQC', 'BsmtQual')
qual.list <- c('None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)
df<- map.fcn(qual.cols, qual.list, df)
group.prices('Functional')
functional.list <- c('None' = 0, 'Sal' = 1, 'Sev' = 2, 'Maj2' = 3, 'Maj1' = 4, 'Mod' = 5, 'Min2' = 6, 'Min1' = 7, 'Typ'= 8)
df$Functional <- as.numeric(functional.list[df$Functional])
group.prices('GarageFinish')
garage.fin.list <- c('None' = 0,'Unf' = 1, 'RFn' = 1, 'Fin' = 2)
df$GarageFinish <- as.numeric(garage.fin.list[df$GarageFinish])
group.prices('Fence')
fence.list <- c('None' = 0, 'MnWw' = 1, 'GdWo' = 1, 'MnPrv' = 2, 'GdPrv' = 4)
df$Fence <- as.numeric(fence.list[df$Fence])
group.prices('MSSubClass')
MSdwelling.list <- c('20' = 1, '30'= 0, '40' = 0, '45' = 0,'50' = 0, '60' = 1, '70' = 0, '75' = 0, '80' = 0, '85' = 0, '90' = 0, '120' = 1, '150' = 0, '160' = 0, '180' = 0, '190' = 0)
df$MSSubClass <- as.numeric(MSdwelling.list[as.character(df$MSSubClass)])
for(i in colnames(df[,sapply(df, is.character)])){
df[,i] <- as.factor(df[,i])
}
df$OverallQual <- as.factor(df$OverallQual)
df$OverallCond <- as.factor(df$OverallCond)
str(df)
require(Matrix) # matrix transformations
require(glmnet) # ridge, lasso & elastinet
require(xgboost) # gbm
require(randomForest)
require(Metrics) # rmse
require(dplyr) # load this in last so plyr doens't overlap it
require(caret) # one hot encoding
require(scales) # plotting $$
require(e1071) # skewness
require(corrplot) # correlation plot
Mode <- function(x) {
ux <- unique(x)
ux[which.max(tabulate(match(x, ux)))]
}
setwd("C:/Users/Michal/Documents/01- Master Degree/GitHub/ST443-Project-group9/Housing price data")
getwd()
train = read.csv("train.csv", row.names = "Id", stringsAsFactors=FALSE)
testing_kaggle = read.csv("test.csv", row.names = "Id", stringsAsFactors=FALSE)
#combining train and test data for quicker data prep
testing_kaggle$SalePrice <- NA
train$isTrain <- 1
testing_kaggle$isTrain <- 0
df <- rbind(train,testing_kaggle)
hist(df$SalePrice)
colSums(sapply(df, is.na))
df[,c('PoolQC','PoolArea')] %>%
group_by(PoolQC) %>%
summarise(mean = mean(PoolArea), counts = n())
df[(df$PoolArea > 0) & is.na(df$PoolQC),c('PoolQC','PoolArea')]
df[2421,'PoolQC'] = 'Ex'
df[2504,'PoolQC'] = 'Ex'
df[2600,'PoolQC'] = 'Fa'
df$PoolQC[is.na(df$PoolQC)] = 'None'
length(which(df$GarageYrBlt == df$YearBuilt))
df[which(is.na(df$GarageYrBlt)), 'GarageYrBlt'] <- df[which(is.na(df$GarageYrBlt)), 'YearBuilt']
garage.cols <- c('GarageArea', 'GarageCars', 'GarageQual', 'GarageFinish', 'GarageCond', 'GarageType')
#df[is.na(df$GarageCond),garage.cols]
for(i in garage.cols){
if (sapply(df[i], is.numeric) == TRUE){
df[,i][which(is.na(df[,i]))] <- 0
}
else{
df[,i][which(is.na(df[,i]))] <- "None"
}
}
df$KitchenQual[which(is.na(df$KitchenQual))] <- Mode(df$KitchenQual)
df[is.na(df$MSZoning),c('MSZoning','MSSubClass')]
table(df$MSZoning, df$MSSubClass)
df$MSZoning[c(2217, 2905)] = 'RL'
df$MSZoning[c(1916, 2251)] = 'RM'
df$LotFrontage[which(is.na(df$LotFrontage))] <- median(df$LotFrontage,na.rm = T)
df$Alley[which(is.na(df$Alley))] <- "None"
#df[(df$MasVnrArea > 0) & (is.na(df$MasVnrType)),c('MasVnrArea','MasVnrType')]
df[2611, 'MasVnrType'] = 'BrkFace'
df$MasVnrType[is.na(df$MasVnrType)] = 'None'
df$MasVnrArea[is.na(df$MasVnrArea)] = 0
for(i in colnames(df[,sapply(df, is.character)])){
if (sum(is.na(df[,i])) < 5){
df[,i][which(is.na(df[,i]))] <- Mode(df[,i])
}
}
for(i in colnames(df[,sapply(df, is.integer)])){
if (sum(is.na(df[,i])) < 5){
df[,i][which(is.na(df[,i]))] <- median(df[,i], na.rm = T)
}
}
for(i in colnames(df[,sapply(df, is.character)])){
df[,i][which(is.na(df[,i]))] <- "None"
}
colSums(sapply(df, is.na))
sum(is.na(df)) == 1459
str(df)
train <- df[df$isTrain==1,]
group.prices <- function(col) {
group.table <- train[,c(col, 'SalePrice', 'OverallQual')] %>%
group_by_(col) %>%
summarise(mean.Quality = round(mean(OverallQual),2),
mean.Price = mean(SalePrice), n = n()) %>%
arrange(mean.Quality)
print(qplot(x=reorder(group.table[[col]], -group.table[['mean.Price']]), y=group.table[['mean.Price']]) +
geom_bar(stat='identity', fill='cornflowerblue') +
theme_minimal() +
scale_y_continuous(labels = dollar) +
labs(x=col, y='Mean SalePrice') +
theme(axis.text.x = element_text(angle = 45)))
return(data.frame(group.table))
}
# function that maps a categoric value to its corresponding numeric value and returns that column to the data frame
map.fcn <- function(cols, map.list, dataframe1){
for (col in cols){
dataframe1[col] <- as.numeric(map.list[df[,col]])
}
return(dataframe1)
}
bsmt_list <- c('None' = 0, 'No' = 1, 'Mn' = 2, 'Av' = 3, 'Gd' = 4)
df = map.fcn(c('BsmtExposure'), bsmt_list, df)
bsmt_fin_list <- c('None' = 0, 'Unf' = 1, 'LwQ' = 2,'Rec'= 3, 'BLQ' = 4, 'ALQ' = 5, 'GLQ' = 6)
df <- map.fcn(c('BsmtFinType1','BsmtFinType2'), bsmt_fin_list, df)
qual.cols <- c('ExterQual', 'ExterCond', 'GarageQual', 'GarageCond', 'FireplaceQu', 'KitchenQual', 'HeatingQC', 'BsmtQual')
qual.list <- c('None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)
df<- map.fcn(qual.cols, qual.list, df)
group.prices('Functional')
functional.list <- c('None' = 0, 'Sal' = 1, 'Sev' = 2, 'Maj2' = 3, 'Maj1' = 4, 'Mod' = 5, 'Min2' = 6, 'Min1' = 7, 'Typ'= 8)
df$Functional <- as.numeric(functional.list[df$Functional])
group.prices('GarageFinish')
garage.fin.list <- c('None' = 0,'Unf' = 1, 'RFn' = 1, 'Fin' = 2)
df$GarageFinish <- as.numeric(garage.fin.list[df$GarageFinish])
group.prices('Fence')
fence.list <- c('None' = 0, 'MnWw' = 1, 'GdWo' = 1, 'MnPrv' = 2, 'GdPrv' = 4)
df$Fence <- as.numeric(fence.list[df$Fence])
group.prices('MSSubClass')
#MSdwelling.list <- c('20' = 1, '30'= 0, '40' = 0, '45' = 0,'50' = 0, '60' = 1, '70' = 0, '75' = 0, '80' = 0, '85' = 0, '90' = 0, '120' = 1, '150' = 0, '160' = 0, '180' = 0, '190' = 0)
#df$MSSubClass <- as.numeric(MSdwelling.list[as.character(df$MSSubClass)])
for(i in colnames(df[,sapply(df, is.character)])){
df[,i] <- as.factor(df[,i])
}
df$MSSubClass <- as.factor(df$MSSubClass)
df$OverallQual <- as.factor(df$OverallQual)
df$OverallCond <- as.factor(df$OverallCond)
str(df)
require(Matrix) # matrix transformations
require(glmnet) # ridge, lasso & elastinet
require(xgboost) # gbm
require(randomForest)
require(Metrics) # rmse
require(dplyr) # load this in last so plyr doens't overlap it
require(caret) # one hot encoding
require(scales) # plotting $$
require(e1071) # skewness
require(corrplot) # correlation plot
Mode <- function(x) {
ux <- unique(x)
ux[which.max(tabulate(match(x, ux)))]
}
setwd("C:/Users/Michal/Documents/01- Master Degree/GitHub/ST443-Project-group9/Housing price data")
getwd()
train = read.csv("train.csv", row.names = "Id", stringsAsFactors=FALSE)
testing_kaggle = read.csv("test.csv", row.names = "Id", stringsAsFactors=FALSE)
#combining train and test data for quicker data prep
testing_kaggle$SalePrice <- NA
train$isTrain <- 1
testing_kaggle$isTrain <- 0
df <- rbind(train,testing_kaggle)
hist(df$SalePrice)
colSums(sapply(df, is.na))
df[,c('PoolQC','PoolArea')] %>%
group_by(PoolQC) %>%
summarise(mean = mean(PoolArea), counts = n())
df[(df$PoolArea > 0) & is.na(df$PoolQC),c('PoolQC','PoolArea')]
df[2421,'PoolQC'] = 'Ex'
df[2504,'PoolQC'] = 'Ex'
df[2600,'PoolQC'] = 'Fa'
df$PoolQC[is.na(df$PoolQC)] = 'None'
length(which(df$GarageYrBlt == df$YearBuilt))
df[which(is.na(df$GarageYrBlt)), 'GarageYrBlt'] <- df[which(is.na(df$GarageYrBlt)), 'YearBuilt']
garage.cols <- c('GarageArea', 'GarageCars', 'GarageQual', 'GarageFinish', 'GarageCond', 'GarageType')
#df[is.na(df$GarageCond),garage.cols]
for(i in garage.cols){
if (sapply(df[i], is.numeric) == TRUE){
df[,i][which(is.na(df[,i]))] <- 0
}
else{
df[,i][which(is.na(df[,i]))] <- "None"
}
}
df$KitchenQual[which(is.na(df$KitchenQual))] <- Mode(df$KitchenQual)
df[is.na(df$MSZoning),c('MSZoning','MSSubClass')]
table(df$MSZoning, df$MSSubClass)
df$MSZoning[c(2217, 2905)] = 'RL'
df$MSZoning[c(1916, 2251)] = 'RM'
df$LotFrontage[which(is.na(df$LotFrontage))] <- median(df$LotFrontage,na.rm = T)
df$Alley[which(is.na(df$Alley))] <- "None"
#df[(df$MasVnrArea > 0) & (is.na(df$MasVnrType)),c('MasVnrArea','MasVnrType')]
df[2611, 'MasVnrType'] = 'BrkFace'
df$MasVnrType[is.na(df$MasVnrType)] = 'None'
df$MasVnrArea[is.na(df$MasVnrArea)] = 0
for(i in colnames(df[,sapply(df, is.character)])){
if (sum(is.na(df[,i])) < 5){
df[,i][which(is.na(df[,i]))] <- Mode(df[,i])
}
}
for(i in colnames(df[,sapply(df, is.integer)])){
if (sum(is.na(df[,i])) < 5){
df[,i][which(is.na(df[,i]))] <- median(df[,i], na.rm = T)
}
}
for(i in colnames(df[,sapply(df, is.character)])){
df[,i][which(is.na(df[,i]))] <- "None"
}
colSums(sapply(df, is.na))
sum(is.na(df)) == 1459
str(df)
train <- df[df$isTrain==1,]
group.prices <- function(col) {
group.table <- train[,c(col, 'SalePrice', 'OverallQual')] %>%
group_by_(col) %>%
summarise(mean.Quality = round(mean(OverallQual),2),
mean.Price = mean(SalePrice), n = n()) %>%
arrange(mean.Quality)
print(qplot(x=reorder(group.table[[col]], -group.table[['mean.Price']]), y=group.table[['mean.Price']]) +
geom_bar(stat='identity', fill='cornflowerblue') +
theme_minimal() +
scale_y_continuous(labels = dollar) +
labs(x=col, y='Mean SalePrice') +
theme(axis.text.x = element_text(angle = 45)))
return(data.frame(group.table))
}
# function that maps a categoric value to its corresponding numeric value and returns that column to the data frame
map.fcn <- function(cols, map.list, dataframe1){
for (col in cols){
dataframe1[col] <- as.numeric(map.list[df[,col]])
}
return(dataframe1)
}
bsmt_list <- c('None' = 0, 'No' = 1, 'Mn' = 2, 'Av' = 3, 'Gd' = 4)
df = map.fcn(c('BsmtExposure'), bsmt_list, df)
bsmt_fin_list <- c('None' = 0, 'Unf' = 1, 'LwQ' = 2,'Rec'= 3, 'BLQ' = 4, 'ALQ' = 5, 'GLQ' = 6)
df <- map.fcn(c('BsmtFinType1','BsmtFinType2'), bsmt_fin_list, df)
qual.cols <- c('ExterQual', 'ExterCond', 'GarageQual', 'GarageCond', 'FireplaceQu', 'KitchenQual', 'HeatingQC', 'BsmtQual')
qual.list <- c('None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)
df<- map.fcn(qual.cols, qual.list, df)
group.prices('Functional')
functional.list <- c('None' = 0, 'Sal' = 1, 'Sev' = 2, 'Maj2' = 3, 'Maj1' = 4, 'Mod' = 5, 'Min2' = 6, 'Min1' = 7, 'Typ'= 8)
df$Functional <- as.numeric(functional.list[df$Functional])
group.prices('GarageFinish')
garage.fin.list <- c('None' = 0,'Unf' = 1, 'RFn' = 1, 'Fin' = 2)
df$GarageFinish <- as.numeric(garage.fin.list[df$GarageFinish])
group.prices('Fence')
fence.list <- c('None' = 0, 'MnWw' = 1, 'GdWo' = 1, 'MnPrv' = 2, 'GdPrv' = 4)
df$Fence <- as.numeric(fence.list[df$Fence])
group.prices('MSSubClass')
#MSdwelling.list <- c('20' = 1, '30'= 0, '40' = 0, '45' = 0,'50' = 0, '60' = 1, '70' = 0, '75' = 0, '80' = 0, '85' = 0, '90' = 0, '120' = 1, '150' = 0, '160' = 0, '180' = 0, '190' = 0)
#df$MSSubClass <- as.numeric(MSdwelling.list[as.character(df$MSSubClass)])
for(i in colnames(df[,sapply(df, is.character)])){
df[,i] <- as.factor(df[,i])
}
df$MSSubClass <- as.factor(df$MSSubClass)
#df$OverallQual <- as.factor(df$OverallQual)
#df$OverallCond <- as.factor(df$OverallCond)
str(df)
train_df <- df[df$isTrain==1,]
test_kaggle <- df[df$isTrain==0,]
train_df$isTrain <- NULL
test_kaggle$isTrain <- NULL
test_kaggle$SalePrice <- NULL
X_train<- model.matrix(SalePrice~.-1, data = train_df)
y_train <- train$SalePrice
X_test <- model.matrix(~., data=test_kaggle)
cv.lasso <-cv.glmnet(X_train, y_train, nfolds = 10, alpha = 1)
plot(cv.lasso)
#here is an example why should we apply the one standard deviation error rule!
penalty_min <- cv.lasso$lambda.min #optimal lambda
penalty_1se <- cv.lasso$lambda.1se # 1 Standard Error Apart
fit.lasso_min <-glmnet(X_train, y_train, alpha = 1, lambda = penalty_min) #estimate the model with min lambda
fit.lasso_1se <-glmnet(X_train, y_train, alpha = 1, lambda = penalty_1se) #estimate the model with 1se apart
penalty_min <- cv.lasso$lambda.min #optimal lambda
penalty_1se <- cv.lasso$lambda.1se # 1 Standard Error Apart
fit.lasso_min <-glmnet(X_train, y_train, alpha = 1, lambda = penalty_min) #estimate the model with min lambda
fit.lasso_1se <-glmnet(X_train, y_train, alpha = 1, lambda = penalty_1se) #estimate the model with 1se apart
prediction_LASSO_min <- predict(fit.lasso_min, X_test)
prediction_LASSO_1se <- predict(fit.lasso_1se, X_test)
prediction_LASSO_min <-cbind(Id = rownames(prediction_LASSO_min), SalesPrice = prediction_LASSO_min)
prediction_LASSO_1se <- cbind(Id = rownames(prediction_LASSO_1se), SalesPrice = prediction_LASSO_1se)
prediction_LASSO_min <- predict(fit.lasso_min, X_test)
prediction_LASSO_1se <- predict(fit.lasso_1se, X_test)
prediction_LASSO_min <-cbind(Id = rownames(prediction_LASSO_min), SalesPrice = prediction_LASSO_min)
prediction_LASSO_1se <- cbind(Id = rownames(prediction_LASSO_1se), SalesPrice = prediction_LASSO_1se)
write.table(prediction_LASSO_min, file="prediction_LASSO_min.csv",col.names = c("Id", "SalePrice"), sep =',', row.names = FALSE)
write.table(prediction_LASSO_1se, file="prediction_LASSO_1se.csv",col.names = c("Id", "SalePrice"), sep =',', row.names = FALSE)
require(Matrix) # matrix transformations
require(glmnet) # ridge, lasso & elastinet
require(xgboost) # gbm
require(randomForest)
require(Metrics) # rmse
require(dplyr) # load this in last so plyr doens't overlap it
require(caret) # one hot encoding
require(scales) # plotting $$
require(e1071) # skewness
require(corrplot) # correlation plot
Mode <- function(x) {
ux <- unique(x)
ux[which.max(tabulate(match(x, ux)))]
}
setwd("C:/Users/Michal/Documents/01- Master Degree/GitHub/ST443-Project-group9/Housing price data")
getwd()
train = read.csv("train.csv", row.names = "Id", stringsAsFactors=FALSE)
testing_kaggle = read.csv("test.csv", row.names = "Id", stringsAsFactors=FALSE)
#combining train and test data for quicker data prep
testing_kaggle$SalePrice <- NA
train$isTrain <- 1
testing_kaggle$isTrain <- 0
df <- rbind(train,testing_kaggle)
hist(df$SalePrice)
colSums(sapply(df, is.na))
df[,c('PoolQC','PoolArea')] %>%
group_by(PoolQC) %>%
summarise(mean = mean(PoolArea), counts = n())
df[(df$PoolArea > 0) & is.na(df$PoolQC),c('PoolQC','PoolArea')]
df[2421,'PoolQC'] = 'Ex'
df[2504,'PoolQC'] = 'Ex'
df[2600,'PoolQC'] = 'Fa'
df$PoolQC[is.na(df$PoolQC)] = 'None'
length(which(df$GarageYrBlt == df$YearBuilt))
df[which(is.na(df$GarageYrBlt)), 'GarageYrBlt'] <- df[which(is.na(df$GarageYrBlt)), 'YearBuilt']
garage.cols <- c('GarageArea', 'GarageCars', 'GarageQual', 'GarageFinish', 'GarageCond', 'GarageType')
#df[is.na(df$GarageCond),garage.cols]
for(i in garage.cols){
if (sapply(df[i], is.numeric) == TRUE){
df[,i][which(is.na(df[,i]))] <- 0
}
else{
df[,i][which(is.na(df[,i]))] <- "None"
}
}
df$KitchenQual[which(is.na(df$KitchenQual))] <- Mode(df$KitchenQual)
df[is.na(df$MSZoning),c('MSZoning','MSSubClass')]
table(df$MSZoning, df$MSSubClass)
df$MSZoning[c(2217, 2905)] = 'RL'
df$MSZoning[c(1916, 2251)] = 'RM'
df$LotFrontage[which(is.na(df$LotFrontage))] <- median(df$LotFrontage,na.rm = T)
df$Alley[which(is.na(df$Alley))] <- "None"
#df[(df$MasVnrArea > 0) & (is.na(df$MasVnrType)),c('MasVnrArea','MasVnrType')]
df[2611, 'MasVnrType'] = 'BrkFace'
df$MasVnrType[is.na(df$MasVnrType)] = 'None'
df$MasVnrArea[is.na(df$MasVnrArea)] = 0
for(i in colnames(df[,sapply(df, is.character)])){
if (sum(is.na(df[,i])) < 5){
df[,i][which(is.na(df[,i]))] <- Mode(df[,i])
}
}
for(i in colnames(df[,sapply(df, is.integer)])){
if (sum(is.na(df[,i])) < 5){
df[,i][which(is.na(df[,i]))] <- median(df[,i], na.rm = T)
}
}
for(i in colnames(df[,sapply(df, is.character)])){
df[,i][which(is.na(df[,i]))] <- "None"
}
colSums(sapply(df, is.na))
sum(is.na(df)) == 1459
str(df)
for(i in colnames(df[,sapply(df, is.character)])){
df[,i] <- as.factor(df[,i])
}
df$MSSubClass <- as.factor(df$MSSubClass)
df$OverallQual <- as.factor(df$OverallQual)
df$OverallCond <- as.factor(df$OverallCond)
str(df)
library(boot)
library(leaps)
library(tree) # Normal Tree
library(MASS) #?
library(randomForest) # random Forest
library(xgboost) # boosting trees
library(Matrix) #?
library(methods) #?
library(caret) # for tuning xgboost
str(df)
train_df <- df[df$isTrain==1,]
test_kaggle <- df[df$isTrain==0,]
train_df$isTrain <- NULL
test_kaggle$isTrain <- NULL
test_kaggle$SalePrice <- NULL
X_train<- model.matrix(SalePrice~.-1, data = train_df)
y_train <- train$SalePrice
X_test <- model.matrix(~., data=test_kaggle)
##Bagging
library(randomForest)
set.seed(1)
## Recall that bagging is simply a special case of a random forest with m=p, here we use mtry=13, i.e. bagging would be done
bag.SalePrice <-randomForest(SalePrice~., data=train_df, mtry= 79, importance=TRUE)
bag.SalePrice
prediction_bag <- predict(bag.SalePrice, newdata = test_kaggle)
prediction_bag <- cbind(Id = rownames(prediction_bag), SalesPrice = prediction_bag)
prediction_bag <- cbind(Id = rownames(prediction_bag), SalesPrice = prediction_bag)
write.table(prediction_bag, file="prediction_bag.csv",col.names = c("Id", "SalePrice"), sep =',', row.names = FALSE)
View(prediction_bag)
View(prediction_bag)
## We could change the number of trees grown by randomForest() using ntree argument
RF_p3.SalePrice <-randomForest(SalePrice~., data=train_df, mtry = 26, importance=TRUE)
View(train_df)
prediction_RF_p3 <- predict(RF_p3.SalePrice, newdata = test_kaggle)
prediction_RF_p3 <- cbind(Id = rownames(prediction_RF_p3), SalesPrice = prediction_RF_p3)
prediction_RF_p3 <- cbind(Id = rownames(prediction_RF_p3), SalesPrice = prediction_RF_p3)
write.table(prediction_RF_p3, file="prediction_RF_p3.csv",col.names = c("Id", "SalePrice"), sep =',', row.names = FALSE)
